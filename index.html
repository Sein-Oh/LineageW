<!DOCTYPE html>
<html>

<head>
    <title>LINEAGE W - 2022.08.12</title>
    <style>
        body {
            background-color: gray;
            font-size: 22px;
            color: white;
        }

        video {
            border: 1px solid white;
            border-radius: 5px;
            margin-top: 5px;
            width: 640px;
            height: 360px;
        }

        div.container {
            width: 640px;
            text-align: center;
        }

        div.container.hide {
            display: none;
        }

        button {
            width: 120px;
            background-color: transparent;
            color: white;
            border: 1px solid white;
            border-radius: 5px;
            font-size: 22px;
            cursor: pointer;
        }

        button.toggle {
            color: white;
        }

        button.on {
            color: white;
            text-shadow:
                0 0 7px #0fa, 0 0 10px #0fa, 0 0 21px #0fa, 0 0 32px #0fa, 0 0 52px #0fa;
        }

        button:hover {
            box-shadow: 0 0 7px white;
        }

        button:active {
            box-shadow: 0 0 7px white, 0 0 10px white;
        }
    </style>
    <script async src="https://docs.opencv.org/4.5.5/opencv.js" onload="cvReady()" type="text/javascript"></script>
</head>

<body>
    <div class="container">
        <button id="start" class="toggle" onclick="loadFile()">CAPTURE</button>
        <button id="connect" class="toggle" onclick="connect()">ARDUINO</button>
        <button id="run" class="toggle" onclick="run()">RUN</button>
        <button id="test" onclick="test()">TEST</button>
        <button id="show" class="toggle" onclick="showDetails()">DETAILS</button>
    </div>
    <video id="video" autoplay></video>
    <br>
    <div id="info"></div>
    <div id="details" class="container hide">
        <canvas id="hpImg"></canvas>
        <canvas id="hpImgRed"></canvas>
        <canvas id="hpImgBlur"></canvas>
        <canvas id="hpImgThres"></canvas>
        <canvas id="mpImg"></canvas>
        <canvas id="mpImgBlue"></canvas>
    </div>
</body>
<script defer>
    let port, writer, potionTarget, pkTarget;
    let running = false;
    let potionEmpty = false;
    let onPk = false;
    let cvLoad = false;
    const encoder = new TextEncoder();
    const video = document.querySelector("#video");
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    const potionEmptyImg = new Image();
    const pkImg = new Image();

    const userData = {
        "capture": {
            "hpPos": { "x": 92, "y": 32, "w": 184, "h": 7 },
            "mpPos": { "x": 92, "y": 46, "w": 184, "h": 7 }
        },

        "autoHome": {
            "use": false,
            "min": 5,
            "max": 40,
            "key": "8",
            "keyCount": 4,
            "keyDelay": 0.5
        },

        "autoHeal": {
            "use": false,
            "min": 45,
            "max": 70,
            "mp": 30,
            "key": "4",
            "cooltime": 5,
            "cool":false
        },

        "potionHome": {
            "use": false,
            "key": "8",
            "keyCount": 4,
            "keyDelay": 0.5,
            "x": 472,
            "y": 635,
            "w": 13,
            "h": 13,
            "thres": 1000000
        },

        "pkAction": {
            "use": false,
            "key": "7",
            "x": 1057,
            "y": 533,
            "w": 25,
            "h": 25,
            "thres": 1000000
        },

        "autoFunc": {
            "use": false,
            "key": "1",
            "min": 25,
            "max": 40,
            "cooltime": 1,
            "cool": false
        }
    }

    const showDetails = () => {
        if (document.querySelector("#details").classList.value.includes("hide")) {
            document.querySelector("#details").classList.remove("hide");
            document.querySelector("#show").classList.add("on");
        } else {
            document.querySelector("#details").classList.add("hide");
            document.querySelector("#show").classList.remove("on");
        }
    }

    const cvReady = () => {
        cvLoad = true;
        console.log("Opencv ready.");
        potionEmptyImg.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAAAXNSR0IArs4c6QAAAjdJREFUKFMdkE1LVGEAhZ/3fjj3Xp0740zmlBsx8gPTmHIRFAW1EaMpLapFQYSraNUmSGiRVrZpUwuhQCikiIJq4aIW/YGg2oY05pgbp5zr6NyZ+/G+4Zz94XnOEc8eXFcmCj2OCfw6cayQCqQEwzCw7ASNKES3LaSuEUkQL2YnVRJFolqltPSLQOpUvCpKgpt0SNoGbkeW2HWpJxKsV2uIN9PX1MbSTyzPwxQGxXKVOx8WQSkeX5xgb7IFYYDvtCIzGUq1BuL1zdMqWF3GajQw29r5uuYxs/iZndwrjDKQNsGv0tB1okyWWm4PYq4wrLJBDVuDTWnw3ZM8+vQFUEyNnqLfinAJiQDfTRH19yPmC8MqpwJMTeC3tPHDi5h697Gp9/B8gX1mQFqEhHFM2TAw8ocRrybyyt320DRBYCVZxeHG/AKUVnhy+xY5tUUiqKFpGp5lU+vtQyyM51Vqu4KUMYFps2EkmZyZpb5c5OXcUzq0ADP0mxsrCQu/dwDxfHxEdcoGpgzxlcZaZFAqexi6Rk9nlix1zLhBoGiSoh3SlV5XHd/fTVbWkZrBt3KN+80jYObsGAczFnpUJ7RbWQlC2g/lEZdHulWP69CXdhBCo7gVcvft+2Zp+sI5uswIXUh8yyFKpcgNDSKujh1R0abHxu8iI0ODOJZDHMcoqbASBokWjeKfEnbnbnoODGKnXcSlM8eUkJJ4u8bW33XCyj80GSNjST2KOHryBLu6cphJB63FwLEt/gPkt/XajD1j6gAAAABJRU5ErkJggg=="
        pkImg.src = "data:image/png;base64,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"
        setTimeout(() => {
            potionTarget = cv.imread(potionEmptyImg);
            pkTarget = cv.imread(pkImg);
        }, 1000);
    }
    
    const startCapture = async () => {
        if (cvLoad) {
            video.srcObject = await navigator.mediaDevices.getDisplayMedia({
                video: { cursor: "always", frameRate: { ideal: 5, max: 5 } },
                audio: false,
            });
            console.log("캡처를 시작합니다.");
            setTimeout(captureLoop, 500);
        } else {
            alert("Opencv.js가 로드되지 않았습니다.\n새로고침 후 다시 해보세요.");
        }
    }

    const stopCapture = () => {
        const tracks = video.srcObject.getTracks();
        tracks.forEach(track => track.stop());
        video.srcObject = null;
    }

    const loadFile = () => {
        const input = document.createElement("input");
        input.type = "file";
        input.onchange = evt => {
            const selectedFile = evt.target.files[0];
            processJSON(selectedFile);
        };
        input.click();
    }

    const processJSON = file => {
        const reader = new FileReader();
        reader.onload = () => {
            try {
                const data = JSON.parse(reader.result);
                Object.keys(data).forEach(mainKey => {
                    if (mainKey == "capture") {
                        Object.keys(data[mainKey]).forEach(key => {
                            Object.keys(data[mainKey][key]).forEach(k => {
                                userData[mainKey][key][k] = data[mainKey][key][k];
                            });
                        });
                    } else {
                        Object.keys(data[mainKey]).forEach(key => {
                            userData[mainKey][key] = data[mainKey][key];
                        });
                    }
                });
                startCapture();
                document.querySelector("#start").classList.add("on");
            } catch (error) {
                alert("파일 불러오기에 실패했습니다.");
                document.querySelector("#start").classList.remove("on");
            }
        }
        reader.readAsText(file);
    }

    const connect = async () => {
        try {
            port = await navigator.serial.requestPort();
            await port.open({ baudRate: 9600 });
            reader = port.readable.getReader();
            writer = port.writable.getWriter();
            console.log("아두이노가 연결되었습니다.");
            document.querySelector("#connect").classList.add("on");

        } catch (err) {
            console.error("에러: " + err);
            document.querySelector("#connect").classList.remove("on");
        }
    }

    const send = (data) => {
        console.log("Send: " + data);
        const dataArrayBuffer = encoder.encode(data);
        writer.write(dataArrayBuffer);
    }

    const test = () => {
        for (i = 0; i < 5; i++) {
            setTimeout(() => send('i'), i * 1000);
        }
    }

    const run = () => {
        //ON되어있는 상태
        if (document.querySelector("#run").classList.value.includes("on")) {
            running = false;
            document.querySelector("#run").classList.remove("on");
        } else {
            running = true;
            document.querySelector("#run").classList.add("on");
        }
    }

    const captureLoop = () => {
        //video 이미지를 1280x720으로 불러오기
        const canvasFull = document.createElement("canvas");
        const ctxFull = canvasFull.getContext("2d");
        canvasFull.width = video.videoWidth;
        canvasFull.height = video.videoHeight;
        ctxFull.drawImage(video, 0, 0, canvasFull.width, canvasFull.height, 0, 0, 1280, 720);

        //1280x720 이미지에서 물약이미지 잘라오기
        canvas.width = userData.potionHome.w;
        canvas.height = userData.potionHome.h;
        ctx.drawImage(canvasFull, userData.potionHome.x, userData.potionHome.y, userData.potionHome.w, userData.potionHome.h, 0, 0, userData.potionHome.w, userData.potionHome.h);
        const potionImg = cv.imread(canvas);

        //물약 이미지 매칭
        const potionResult = new cv.Mat();
        const potionMask = new cv.Mat();
        cv.matchTemplate(potionTarget, potionImg, potionResult, cv.TM_CCOEFF, potionMask);
        const potionRoc = cv.minMaxLoc(potionResult, potionMask);
        if (Math.round(potionRoc.maxVal) >= userData.potionHome.thres) {
            console.log("물약이 없습니다.");
            potionEmpty = true;
        } else {
            potionEmpty = false;
        }

        //1280x720 이미지에서 PK 부분 잘라오기
        canvas.width = userData.pkAction.w;
        canvas.height = userData.pkAction.h;
        ctx.drawImage(canvasFull, userData.pkAction.x, userData.pkAction.y, userData.pkAction.w, userData.pkAction.h, 0, 0, userData.pkAction.w, userData.pkAction.h);
        const pkImg = cv.imread(canvas);

        //PK 이미지 매칭
        const pkResult = new cv.Mat();
        const pkMask = new cv.Mat();
        cv.matchTemplate(pkTarget, pkImg, pkResult, cv.TM_CCOEFF, pkMask);
        const pkRoc = cv.minMaxLoc(pkResult, pkMask);
        if (Math.round(pkRoc.maxVal) >= userData.pkAction.thres) {
            console.log("전투상태입니다.");
            onPk = true;
        } else {
            onPk = false;
        }

        //1280x720 이미지에서 HP 부분 잘라오기
        canvas.width = userData.capture.hpPos.w;
        canvas.height = userData.capture.hpPos.h;
        ctx.drawImage(canvasFull, userData.capture.hpPos.x, userData.capture.hpPos.y, userData.capture.hpPos.w, userData.capture.hpPos.h, 0, 0, userData.capture.hpPos.w, userData.capture.hpPos.h);
        const hpImg = cv.imread(canvas);
        cv.imshow("hpImg", hpImg);

        //HP Red 값만 추출하기
        const hpImgPlanes = new cv.MatVector();
        cv.split(hpImg, hpImgPlanes);
        const hpRed = hpImgPlanes.get(0);
        cv.imshow("hpImgRed", hpRed);

        //HP 블러 처리하기
        const hpBlur = new cv.Mat();
        const ksize = new cv.Size(5, 5);
        const anchor = new cv.Point(-1, -1)
        cv.blur(hpRed, hpBlur, ksize, anchor, cv.BORDER_DEFAULT);
        cv.imshow("hpImgBlur", hpBlur);

        //HP 임계 처리하기
        const hpThres = new cv.Mat();
        cv.threshold(hpBlur, hpThres, 210, 255, cv.THRESH_BINARY);
        cv.imshow("hpImgThres", hpThres);

        //HP 계산하기
        const hpData1D = [];
        const hpData2D = [];
        const hpMaxAry = [];

        //HP cv.Mat 데이터를 JS array로 가져오기
        hpThres.data.forEach(value => hpData1D.push(value));

        //HP 1차원 데이터를 2차원(x, y)으로 분리하기
        while (hpData1D.length) hpData2D.push(hpData1D.splice(0, hpThres.size().width));

        //배열을 뒤집어서 255값 찾아 배열에 넣기 (우->좌 방향으로 255값 찾기)
        for (i = 0; i < hpData2D.length; i++) {
            // 수정. indexOf에서 값이 검출되지 않으면 -1. Min값을 찾기 때문에 오류 발생하여 수정
            const idx = hpData2D[i].reverse().indexOf(255);
            const value = idx < 0 ? hpImg.size().width : idx;
            hpMaxAry.push(value);
        }

        //hpMaxAry의 가장 작은값 찾아 HP비율로 계산
        const hpMinIdx = Math.min.apply(null, hpMaxAry) < 0 ? 0 : Math.min.apply(null, hpMaxAry);
        const hpRatio_ = Math.round((hpThres.size().width - hpMinIdx) / hpThres.size().width * 100);
        //22.08.22 추가 - HP가 0인 경우 대부분 오류이므로 100%로 인식하도록 조치.
        const hpRatio = hpRatio_ == 0 ? 100 : hpRatio_;

        //1280x720 이미지에서 MP 부분 잘라오기
        canvas.width = userData.capture.mpPos.w;
        canvas.height = userData.capture.mpPos.h;
        ctx.drawImage(canvasFull, userData.capture.mpPos.x, userData.capture.mpPos.y, userData.capture.mpPos.w, userData.capture.mpPos.h, 0, 0, userData.capture.mpPos.w, userData.capture.mpPos.h);
        const mpImg = cv.imread(canvas);

        //MP Blue 값만 추출하기
        const mpLow = new cv.Mat(mpImg.rows, mpImg.cols, mpImg.type(), [60, 110, 125, 0]);
        const mpHigh = new cv.Mat(mpImg.rows, mpImg.cols, mpImg.type(), [120, 200, 200, 255]);
        const mpBlue = new cv.Mat();
        cv.inRange(mpImg, mpLow, mpHigh, mpBlue);
        cv.imshow("mpImgBlue", mpBlue);

        //MP 계산하기
        const mpData1D = [];
        const mpData2D = [];
        const mpMaxAry = [];

        //MP cv.Mat 데이터를 JS array로 가져오기
        mpBlue.data.forEach(value => mpData1D.push(value));

        //MP 1차원 데이터를 2차원(x, y)으로 분리하기
        while (mpData1D.length) mpData2D.push(mpData1D.splice(0, mpBlue.size().width));

        //배열을 뒤집어서 255값 찾아 배열에 넣기 (우->좌 방향으로 255값 찾기)   
        for (i = 0; i < mpData2D.length; i++) {
            // fix. indexOf에서 값이 검출되지 않으면 -1. Min값을 찾기 때문에 오류 발생하여 수정
            const idx = mpData2D[i].reverse().indexOf(255);
            const value = idx < 0 ? mpImg.size().width : idx;
            mpMaxAry.push(value);
        }

        //mpMaxAry의 가장 작은값 찾아 HP비율로 계산
        const mpMinIdx = Math.min.apply(null, mpMaxAry) < 0 ? 0 : Math.min.apply(null, mpMaxAry);
        const mpRatio = Math.round((mpBlue.size().width - mpMinIdx) / mpBlue.size().width * 100);

        document.querySelector("#info").innerHTML = `[HP]${hpRatio}% / [MP]${mpRatio}%`;
        cv.imshow("mpImg", mpImg);

        // 각종 기능 제어하기
        if (running) {
            // Auto home
            if (userData.autoHome.use) {
                if (hpRatio >= userData.autoHome.min && hpRatio <= userData.autoHome.max) {
                    for (i = 0; i < userData.autoHome.keyCount; i++) {
                        setTimeout(() => {
                            console.log("자동귀환이 실행되었습니다.");
                            send(userData.autoHome.key);
                        }, userData.autoHome.keyDelay * i * 1000);
                    }
                    running = false;
                    document.querySelector("#run").classList.remove("on");
                }
            }

            // Auto heal
            if (userData.autoHeal.use) {
                if (hpRatio >= userData.autoHeal.min && hpRatio <= userData.autoHeal.max && mpRatio >= userData.autoHeal.mp && userData.autoHeal.cool == false) {
                    console.log("힐을 사용합니다.");
                    send(userData.autoHeal.key);
                    userData.autoHeal.cool = true;
                    setTimeout(() => {
                        console.log("힐 쿨타임이 초기화되었습니다.")
                        userData.autoHeal.cool = false;
                    }, userData.autoHeal.cooltime * 1000);
                }
            }

            // Potion home
            if (userData.potionHome.use) {
                if (potionEmpty) {
                    for (i = 0; i < userData.potionHome.keyCount; i++) {
                        setTimeout(() => {
                            console.log("물약이 없어 귀환했습니다.");
                            send(userData.potionHome.key);
                        }, userData.potionHome.keyDelay * i * 1000);
                    }
                    running = false;
                    document.querySelector("#run").classList.remove("on");
                }
            }

            // PK action
            if (userData.pkAction.use) {
                if (onPk) {
                    console.log("전투상황에 대응했습니다.");
                    send(userData.pkAction.key);
                }
            }

            // Auto function
            if (userData.autoFunc.use) {
                if (hpRatio >= userData.autoFunc.min && hpRatio <= userData.autoFunc.max && userData.autoFunc.cool == false) {
                    console.log("자동기능을 사용합니다.")
                    send(userData.autoFunc.key);
                    userData.autoFunc.cool = true;
                    setTimeout(() => {
                        userData.autoFunc.cool = false;
                    }, userData.autoFunc.cooltime * 1000);
                }
            }
        }
        potionImg.delete();
        potionResult.delete();
        potionMask.delete();
        pkImg.delete();
        pkResult.delete();
        pkMask.delete();
        hpImg.delete();
        hpImgPlanes.delete();
        hpRed.delete();
        hpBlur.delete();
        hpThres.delete();
        mpLow.delete();
        mpHigh.delete();
        mpBlue.delete();
        mpImg.delete();
        setTimeout(captureLoop, 300);
    }

    alert("2022.08.22 업데이트.\n블로그 글을 참고해 주세요.\nhttps://mandloh.tistory.com/135");


</script>

</html>
